Bayeslite roadmap

* 2015-01-12

ESTIMATE COLUMNS, ESTIMATE PAIRWISE, &c., are silly.  Should just be a
uniform part of SELECT: they're really just select on the table of
columns of a btable.

	SELECT c1.name, c2.name
	  FROM COLUMNS OF t AS c1, COLUMNS OF t AS c2
	  ORDER BY MUTUAL INFORMATION OF c1 WITH c2;

	SELECT SIMILARITY OF r1 TO r2 WITH RESPECT TO (c1, c2)
	  FROM t AS r1, t AS r2;

	SELECT c.name, SIMILARITY OF r1 TO r2 WITH RESPECT TO c
	  FROM COLUMNS OF t AS c, t AS r1, t AS r2;

Problem -- need to be able to use these as select columns:

	SELECT name, (ESTIMATE COLUMNS FROM t ORDER BY TYPICALITY)
	  FROM t ORDER BY name;

INFER should also just be an expression which can be used inside
SELECT:

	SELECT name, INFER age CONF 0.9 FROM t;

On the other hand, SIMULATE makes sense as a table constructor:

	SELECT * FROM (SIMULATE weight, age FROM t) ORDER BY age;

PLOT, SUMMARIZE, HIST, &c., should not be part of the query language.
They should sit outside, like the `.'-commands of the sqlite3 shell:

	bql> .plot SELECT MUTUAL INFORMATION OF c1 WITH c2
	             FROM COLUMNS OF t AS c1, COLUMNS OF t AS c2;

* 2014-11-13

** Major to do

- [1 week] Write parser for BQL and compile it into SQL.
  => Could use the existing BQL parser, but I'm rather disinclined to
     touch that pile of spaghetti.  Would rather throw out pyparsing
     in favour of an NFA scanner and LALR parser.
  => Need to determine how to embed SQL in our grammar.  Would be nice
     to be able to merely extend sqlite's grammar, but that's not a
     trivial task.

- [1-2 days] Implement importing bayesdb tables and models into bayeslite.
  => Should be a SMOP.

- [] Decide how to expose INFER and SIMULATE to BQL.
  => Best would probably be via sqlite virtual tables, which the
     Python sqlite3 module does not support.  May want to replace it
     by a better sqlite3 wrapper, e.g. apsw.

- [] Structural constraints.
- [] Foreign predictors.

** Things bayesdb has that bayeslite doesn't

- [1 day] Parallel analysis.
  => Not difficult in principle: spawn a thread that runs
     bayesdb_model_analyze1.

- [2-4 days] Remote server.
  => Not difficult in principle once there is a parser: the core API
     of bayeslite is noninteractive and composable.

- [1-2 days] Runnable examples.
- [] Automatic tests (requires me to know what to meaningfully test).
- [] Interactive UI.

** Things bayeslite has that bayesdb doesn't

- Noninteractive API.
- Relational SQL queries.

** Random long-term notes

The approach taken with sqlite, to extend SQL with functions that
compute BayesDB functionality by calling into the backend, would work
with PGSQL too, in case we want to take that path -- provided it is OK
to run the computations in the PGSQL process.
