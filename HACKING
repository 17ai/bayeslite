* Automatic tests

Every commit on long-term branches including master should pass

   % ./check.sh

which builds bayeslite and runs most of the automatic tests.  Please
run this in your .git/hooks/pre-commit script during development.
An example pre-commit file is provided:
   % ln -s `pwd`/tests/pre-commit .git/hooks/pre-commit

We also recommend:
   % ./check.sh lint
   % ./check.sh cov
and of course please add tests in tests/ or shell/tests



check.sh does a clean build of bayeslite into the build/ directory and
then either runs `py.test tests shell', if you pass it no arguments;
or runs py.test with the arguments supplied.

Thus, if you're hacking a limited part of bayeslite, you can, e.g.,
run a subset of tests, and stop at the first failure, with

   % ./check.sh lint src/frobnitz.py tests/test_frobnitz.py
   % ./check.sh -x tests/test_frobnitz.py

However, please double-check that every commit you have made passes
all tests before publishing the commits.  Because check.sh skips slow
tests, we may contact you after you commit if your change caused our
continuous integration to fail.

We recommend creating a pull request and if we haven't reviewed it in
a day or so, pinging someone you know on the team, or sending mail to
probcomp@csail.mit.edu.  Thanks!


* Randomization

Avoid indiscriminate nondeterminism.

All random choices should be made from PRNGs with seeds that the user
can control, via the normal Python API and the bayeslite shell.  Any
actual nondeterminism should be clearly labelled as such, e.g. a
future shell command to choose a seed from /dev/urandom.

(Crosscat is currently nondeterministc, but this is a bug in
Crosscat.)

* SQL/BQL parameters

Use SQL/BQL parameters to pass strings and other values into SQL/BQL.
DO NOT use format strings.

DO:     db.execute('UPDATE foo SET x = ? WHERE id = ?', (x, id))
DON'T:  db.execute("UPDATE foo SET x = '%s' WHERE id = %d" % (x, id))
DON'T:  db.execute("UPDATE foo SET x = '{}' WHERE id = {}".format(x, id))

DO:     db.execute('SELECT x, y FROM t WHERE z = ?', (z,))
DON'T:  db.execute('SELECT x, y FROM t WHERE z = ?', z)
DON'T:  db.execute('SELECT x, y FROM t WHERE z = {}'.format(z))

Prefer named parameters if the query has more than one parameter and
covers multiple lines:

        cursor = db.execute('''
            SELECT COUNT(*)
                FROM bayesdb_generator AS g, bayesdb_column AS c
                WHERE g.id = :generator_id
                    AND g.tabname = c.tabname
                    AND c.colno = :colno
        ''', {
            'generator_id': generator_id,
            'colno': colno,
        })

If the tables and columns in the query are determined dynamically,
then use sqlite3_quote_name and format strings to assemble SQL/BQL
queries.  But prefer to avoid this by writing different queries or
reusing subroutines that already do it, such as in bayeslite.core.

DO:     qt = sqlite3_quote_name(table)
        qc = sqlite3_quote_name(column)
        db.execute('SELECT %s FROM %s WHERE x = ?' % (qc, qt), (x,))

DON'T:  db.execute('SELECT %s FROM %s WHERE x = ?' % (column, table), (x,))
DON'T:  db.execute('SELECT %s FROM %s WHERE x = %d' % (qc, qt, x))

* SQL updates

When issuing an UPDATE command to sqlite3, if you can count the number
of rows it should affect, do so and assert that it affected that many
rows:

    total_changes = bdb.sqlite3.total_changes
    bdb.sql_execute('UPDATE ...', (...))
    assert bdb.sqlite3.total_changes - total_changes == 1

XXX Should not use bdb.sqlite3 explicitly here.
XXX Not every use is so marked.

* Python coding style

Generally follow PEP 8, with these exceptions:

- Single line between top-level definitions.
  => Two blank lines are needlessly verbose.

Additional guidelines:

- General API should be exposed in the bayeslite module.
- General names should begin with the lexeme `bayesdb' or `bql'.
- Prefer greppable descriptive global functions over methods.
  => Legibility is more important than extensibility.
- Prefer single-quoted strings, except use """ for docstrings.
- unicode for user data; str for SQL/BQL text.
- Prefer clarity over boilerplate.
  => No need to clutter every docstring with a sphinx template.
